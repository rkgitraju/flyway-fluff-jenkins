import os
import re
import subprocess
import sys
import shutil
from datetime import datetime

# --- Configuration (UPDATE THESE VALUES) ---
# NOTE: Ensure the user/password/port match your Docker Compose setup.
# IMPORTANT: 'db1' and 'db2' are the Docker service names (hostnames)
SOURCE_DB_URL = "postgresql://airflow:airflow@db1:5432/db1" 
TARGET_DB_URL = "postgresql://airflow:airflow@db2:5432/db2"

MIGRATION_DIR = "src/main/resources/db/migration/db2"
TARGET_PROFILE = "db2-local"

# Windows/Linux TimeZone fix for JVM/Maven (Use Asia/Kolkata for IST)
MAVEN_OPTS_FIX = "-Duser.timezone=Asia/Kolkata"

# --- Utility Functions ---

def get_next_version(migration_dir):
    """Calculates the next sequential Flyway version."""
    if not os.path.exists(migration_dir):
        return 1
    
    files = os.listdir(migration_dir)
    versions = []
    # Find all V<number>__*.sql files and extract the number
    for f in files:
        match = re.match(r'V(\d+)__.*\.sql$', f)
        if match:
            versions.append(int(match.group(1)))
    
    return max(versions) + 1 if versions else 1

def delete_generated_file(file_path):
    """Safely deletes the generated migration file."""
    if os.path.exists(file_path):
        try:
            os.remove(file_path)
            print(f"üóëÔ∏è Successfully deleted failed migration file: {os.path.basename(file_path)}")
        except OSError as e:
            print(f"‚ö†Ô∏è Warning: Could not delete file {os.path.basename(file_path)}. Please delete manually: {e}")

def clean_migra_output(sql_content):
    """
    Cleans up redundant CREATE SEQUENCE statements often generated by Migra
    when dealing with SERIAL columns, which cause Flyway to fail.
    """
    if not sql_content:
        return ""
    
    lines = sql_content.splitlines()
    cleaned_lines = []
    
    for line in lines:
        stripped_line = line.strip().lower()
        
        # CRITICAL FIX: Skip standalone CREATE SEQUENCE statements.
        # When Migra outputs 'create table ... (id serial ...)', it often outputs
        # a separate 'create sequence ...' which is redundant and causes the 42P07 error.
        if stripped_line.startswith('create sequence'):
            print(f"üßπ Removed redundant statement: {line.strip()}")
            continue
        
        # Filter warnings and noise that might have slipped through
        if 'userwarning:' in stripped_line or 'pkg_resources' in stripped_line or 'schemainspect' in stripped_line:
            continue
            
        cleaned_lines.append(line)
        
    return '\n'.join(cleaned_lines).strip()

# --- Core Logic Functions ---

def run_migra_and_generate_script():
    """Compares the schemas using Migra and generates the Flyway SQL file."""
    
    print("=" * 50)
    print(f"Starting Schema Diff: {SOURCE_DB_URL.split('/')[-1]} -> {TARGET_DB_URL.split('/')[-1]}")
    print("=" * 50)
    
    # 1. Run Migra to get the diff SQL (IMPROVED subprocess call)
    try:
        print("Running Migra to compare schemas...")

        MIGRA_PATH = shutil.which('migra')
        if not MIGRA_PATH:
            raise FileNotFoundError("'migra' executable not found in PATH.")

        migra_command = [MIGRA_PATH, '--unsafe', TARGET_DB_URL, SOURCE_DB_URL]
        
        # Capture output separately for robust error checking
        result = subprocess.run(
            migra_command, 
            capture_output=True, 
            text=True, 
        )
        
        # Check for immediate non-zero exit code (failure)
        if result.returncode != 0 and result.stdout.strip() == "":
             print("‚ùå ERROR: Migra failed unexpectedly.")
             print("--- Subprocess Error (stderr) ---")
             print(result.stderr) 
             sys.exit(1)
        
        # Combine stdout and stderr for cleaning (Migra puts SQL in stdout, warnings in stderr)
        raw_output = result.stdout + result.stderr
        
    except FileNotFoundError as e:
        print(f"‚ùå ERROR: {e}. Check if 'migra' is in your system's PATH.")
        sys.exit(1)
    except Exception as e:
        print(f"‚ùå CRITICAL ERROR: Migra failed during execution: {e}")
        sys.exit(1)
    
    # 2. Clean the output and check for changes
    diff_sql = clean_migra_output(raw_output)
    
    if not diff_sql:
        print("‚úÖ No schema changes detected. Exiting.")
        return None

    # 3. Generate Flyway Script details
    next_version = get_next_version(MIGRATION_DIR)
    # Added seconds to timestamp for better uniqueness
    timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S")
    file_name = f"V{next_version}__{timestamp_str}_schema_sync.sql"
    full_path = os.path.join(MIGRATION_DIR, file_name)

    print(f"Schema changes found. Generating script: {full_path}")

    # 4. Write the captured SQL to the new file
    os.makedirs(MIGRATION_DIR, exist_ok=True)
    # Ensure UTF-8 encoding for safety
    with open(full_path, 'w', encoding='utf-8') as f:
        f.write(f"-- Auto-generated by Migra on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
        f.write(diff_sql)
        f.write("\n\n-- DDL synchronization complete.")
    
    print("-----------------------------------------------------")
    print("Generated SQL Script Contents (Cleaned):")
    print('\n'.join(diff_sql.splitlines()[:5]) + '...')
    print("-----------------------------------------------------")
    
    return full_path

def run_flyway_migration(script_path):
    """Runs the Maven Flyway migrate command with the necessary environment fix."""
    
    # Set the MAVEN_OPTS environment variable for the subprocess
    original_maven_opts = os.environ.get('MAVEN_OPTS')
    os.environ['MAVEN_OPTS'] = MAVEN_OPTS_FIX
    
    print(f"\nRunning Flyway migration on profile '{TARGET_PROFILE}'...")
    
    # Command to run: mvn clean compile flyway:migrate -Pdb2-local
    maven_command = [
        'mvn',
        'clean',
        'compile',
        'flyway:migrate',
        '-P' + TARGET_PROFILE,
    ]
    
    try:
        # Execute the Maven command (IMPROVED: Streaming output and timeout)
        subprocess.run(
            maven_command,
            cwd='/app', # Use the correct working directory for Jenkins/Maven
            env=os.environ,
            check=True, # Will raise CalledProcessError if return code is non-zero
            timeout=180, 
            # Stream output directly to Jenkins console
            stdout=sys.stdout, 
            stderr=sys.stderr, 
        )
        print("\n‚úÖ Flyway migration SUCCESSFUL.")
        return True
    except subprocess.TimeoutExpired as e:
        print("\n‚ùå Flyway migration FAILED.")
        print("üö® ERROR: Flyway execution timed out after 180 seconds.")
        return False
    except subprocess.CalledProcessError as e:
        # Output is already streamed to the console, so just log the failure.
        print("\n‚ùå Flyway migration FAILED. Check console log for detailed SQL error.")
        return False
    finally:
        # Restore the original MAVEN_OPTS
        if original_maven_opts is not None:
            os.environ['MAVEN_OPTS'] = original_maven_opts
        elif 'MAVEN_OPTS' in os.environ:
            del os.environ['MAVEN_OPTS']


if __name__ == "__main__":
    generated_file = None
    try:
        generated_file = run_migra_and_generate_script()
        
        if generated_file is not None :
            print("\nü§ñ Automation Mode: Executing migration.")
            
            success = run_flyway_migration(generated_file)
            
            if success:
                print("\n‚ú® END OF PIPELINE: Schema synchronization successful!")
            else:
                # CRITICAL: Delete the file on failure to prevent future build errors
                delete_generated_file(generated_file)
                print("\n‚ùå END OF PIPELINE: Schema synchronization failed during Flyway run. Exiting with error code.")
                sys.exit(1) 
        else:
            print("\n‚úÖ END OF PIPELINE: No changes to apply.")

    except Exception as e:
        print(f"\n\nüõë A critical error occurred outside the main logic: {e}")
        if generated_file:
            print(f"Attempting to clean up partially generated file: {os.path.basename(generated_file)}")
            delete_generated_file(generated_file)
        sys.exit(1)